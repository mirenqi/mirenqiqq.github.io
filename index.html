<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=3.0, user-scalable=yes">
    <title>ğŸ„ 3Dåœ£è¯æ ‘ - é€ç»™æœ€çˆ±çš„ä½ </title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(180deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        #photo-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999 !important;
        }
        
        #photo-modal.show {
            display: flex !important;
        }
        
        #photo-modal.active {
            display: flex !important;
        }
        
        #modal-photo {
            max-width: 90%;
            max-height: 80%;
            object-fit: contain;
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
            position: relative;
            z-index: 5;
        }
        
        #photo-modal.active #photo-container.zoomed .heart-border {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
        }
        
        html body #photo-modal.active #photo-container.zoomed {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
            background-color: #000000 !important;
            z-index: 9999 !important;
            padding: 0 !important;
            margin: 0 !important;
            overflow: hidden !important;
        }
        
        html body #photo-modal.active #photo-container.zoomed #modal-photo {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw !important;
            max-height: 100vh !important;
            object-fit: contain !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            background-color: transparent !important;
        }
        
        #photo-count {
            position: absolute;
            bottom: 30px;
            color: white;
            font-size: 16px;
            opacity: 0.8;
            z-index: 2002;
        }
        
        .photo-gallery {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        
        #photo-container {
            position: relative;
            display: inline-block;
        }
        
        .heart-border {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: calc(100% + 40px);
            height: calc(100% + 40px);
            pointer-events: none;
            z-index: 10;
        }
        
        #close-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        #close-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }
        
        #photo-count {
            position: absolute;
            bottom: 30px;
            color: white;
            font-size: 16px;
            opacity: 0.8;
        }
        
        .photo-gallery {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }
        
        .gallery-photo {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            object-fit: cover;
            border: 3px solid rgba(255, 215, 0, 0.6);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }
        
        .gallery-photo:hover, .gallery-photo.active {
            transform: scale(1.2);
            border-color: #ffd700;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
        }
        
        #title {
            position: fixed;
            top: 30px;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 28px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            z-index: 50;
            pointer-events: none;
            animation: titleGlow 2s ease-in-out infinite;
        }
        
        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
            50% { text-shadow: 0 0 40px rgba(255, 215, 0, 1), 0 0 60px rgba(255, 100, 100, 0.5); }
        }
        
        #hint {
            position: fixed;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
            z-index: 50;
        }
        
        #snow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .snowflake {
            position: absolute;
            color: white;
            font-size: 15px;
            opacity: 0.8;
            animation: fall linear infinite;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        @keyframes fall {
            0% {
                transform: translateY(-10px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0.3;
            }
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            transition: opacity 0.5s ease;
        }
        
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 215, 0, 0.3);
            border-top-color: #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        #music-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: all 0.3s ease;
            animation: pulse 2s ease-in-out infinite;
        }
        
        #music-btn:hover {
            background: rgba(255, 215, 0, 0.4);
            transform: scale(1.1);
        }
        
        #music-btn.music-playing {
            animation: pulse 2s ease-in-out infinite;
        }
        
        #music-btn.music-paused {
            animation: none;
            opacity: 0.6;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        }

        #background-container {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }

        .bg-image {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            object-fit: cover;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        .bg-image.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader"></div>
    </div>

    <div id="background-container">
        <img class="bg-image active" src="061eb05e60c18dd131b6a44b54c37079.jpg" alt="èƒŒæ™¯1">
        <img class="bg-image" src="1dfce52536fef87edf69f4f4eb38f760.jpg" alt="èƒŒæ™¯2">
        <img class="bg-image" src="518725f26bc7b4a8ed6a1e2f8440fb4a.jpg" alt="èƒŒæ™¯3">
        <img class="bg-image" src="ab99d387ee7f91a2f5eab71aec5d48ca.jpg" alt="èƒŒæ™¯4">
        <img class="bg-image" src="fee95c3bbd94acdd34a5db9dff8394a9.jpg" alt="èƒŒæ™¯5">
    </div>
    
    <div id="snow-container"></div>
    
    <div id="canvas-container"></div>
    
    <h1 id="title">ğŸ„ Merry Christmas ğŸ„</h1>
    
    <div class="photo-gallery">
        <img class="gallery-photo active" data-index="0" src="061eb05e60c18dd131b6a44b54c37079.jpg" alt="ç…§ç‰‡1">
        <img class="gallery-photo" data-index="1" src="1dfce52536fef87edf69f4f4eb38f760.jpg" alt="ç…§ç‰‡2">
        <img class="gallery-photo" data-index="2" src="518725f26bc7b4a8ed6a1e2f8440fb4a.jpg" alt="ç…§ç‰‡3">
        <img class="gallery-photo" data-index="3" src="ab99d387ee7f91a2f5eab71aec5d48ca.jpg" alt="ç…§ç‰‡4">
        <img class="gallery-photo" data-index="4" src="fee95c3bbd94acdd34a5db9dff8394a9.jpg" alt="ç…§ç‰‡5">
    </div>
    
    <div id="photo-modal">
        <div id="close-btn">âœ•</div>
        <div id="photo-container">
            <div class="heart-border"></div>
            <img id="modal-photo" src="" alt="ç…§ç‰‡é¢„è§ˆ">
        </div>
        <div id="photo-count">1 / 5</div>
        <div id="zoom-hint" style="display: none; position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%); color: white; font-size: 14px; opacity: 0.8; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);">ğŸ’¡ åŒå‡»å›¾ç‰‡è¿”å›</div>
    </div>
    
    <div id="hint">ç‚¹å‡»ç²’å­/é›ªèŠ±çˆ†ç‚¸ Â· ç‚¹å‡»ç…§ç‰‡æ”¾å¤§é¢„è§ˆ Â· ç‚¹å‡»å³ä¸‹è§’æ’­æ”¾éŸ³ä¹</div>
    
    <audio id="bgm" preload="auto">
        <source src="è‹æ‰“ç»¿+-+å°æƒ…æ­Œ.mp3" type="audio/mpeg">
    </audio>
    
    <div id="music-btn" class="music-playing">ğŸµ</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ========== é…ç½® ==========
        const CONFIG = {
            photos: [
                '061eb05e60c18dd131b6a44b54c37079.jpg',
                '1dfce52536fef87edf69f4f4eb38f760.jpg',
                '518725f26bc7b4a8ed6a1e2f8440fb4a.jpg',
                'ab99d387ee7f91a2f5eab71aec5d48ca.jpg',
                'fee95c3bbd94acdd34a5db9dff8394a9.jpg'
            ],
            treeColor: 0x1a5f1a,
            ornamentColors: [0xff0000, 0xffd700, 0x0066ff, 0xff69b4, 0x00ff00],
            particleCount: 5000
        };
        
        let currentPhotoIndex = 0;
        let scene, camera, renderer;
        let christmasTree, star, ornaments = [], bells = [];
        let snowflakes = [];
        let galaxyParticles = [];
        let galaxyStars = [];
        let galaxyCore = null;
        let photoDisplay = null;
        let photoDisplayMesh = null;
        let photoDisplayTexture = null;
        let isPhotoDisplayVisible = false;
        let isPhotoZoomed = false;
        let photoDisplayClickCount = 0;
        let photoDisplayClickTimer = null;
        let snowflakesExploded = false;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };
        let cameraDistance = 12;
        let targetCameraDistance = 12;
        let pinchStartDistance = 0;
        let initialCameraDistance = 12;
        let particlesExploded = false;
        let explosionProgress = 0;
        let treeRotationSpeed = 2.5;
        let targetTreeRotationSpeed = 2.5;
        let autoRotateTime = 0;
        let explosionCenter = new THREE.Vector3();
        let originalParticlePositions = null;
        let raycaster, mouse;
        let photoScale = 1;
        let photoPinchStartDistance = 0;
        let photoInitialScale = 1;
        let autoRotate = true;
        let photoZoomed = false;
        
        // ========== åˆå§‹åŒ– ==========
        function init() {
            initThree();
            createChristmasTree();
            createStar();
            createOrnaments();
            createBells();
            createLights();
            createPhotoDisplay();
            createParticles();
            createSnow();
            setupEventListeners();
            animate();
            hideLoading();
        }
        
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a2a, 0.02);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, cameraDistance);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.createElement('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
        }
        
        // ========== åˆ›å»ºæ —å­å½¢åœ£è¯æ ‘ ==========
        function createChristmasTree() {
            const treeGroup = new THREE.Group();
            
            // æ ‘å† å±‚ - æ —å­å½¢çŠ¶ï¼ˆæ¤­åœ†å½¢é”¥ä½“ï¼‰
            const layers = [
                { y: 0, radius: 2.8, height: 3, segments: 32 },
                { y: 2.5, radius: 2.2, height: 2.5, segments: 28 },
                { y: 4.5, radius: 1.6, height: 2, segments: 24 },
                { y: 6.2, radius: 1.0, height: 1.5, segments: 20 },
                { y: 7.5, radius: 0.5, height: 1, segments: 16 }
            ];
            
            layers.forEach((layer, index) => {
                // æ —å­å½¢çŠ¶çš„å‡ ä½•ä½“ - ä½¿ç”¨æ¤­çƒä½“å’Œåœ†é”¥çš„æ··åˆ
                const geometry = new THREE.ConeGeometry(layer.radius, layer.height, layer.segments);
                
                // ä¿®æ”¹é¡¶ç‚¹ä»¥åˆ›å»ºæ —å­å½¢çŠ¶
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const y = positions.getY(i);
                    const normalizedY = (y + layer.height / 2) / layer.height;
                    
                    // æ —å­å½¢çŠ¶çš„å®½åº¦å˜åŒ–
                    const chestnutFactor = Math.sin(normalizedY * Math.PI) * 0.15;
                    const currentRadius = positions.getX(i);
                    const scaleFactor = 1 - chestnutFactor + (Math.random() - 0.5) * 0.1;
                    
                    positions.setX(i, currentRadius * scaleFactor);
                    positions.setZ(i, positions.getZ(i) * (1 - chestnutFactor * 0.5));
                }
                geometry.computeVertexNormals();
                
                // äº”å½©é¢œè‰² - æ¯å±‚ä½¿ç”¨ä¸åŒçš„è‰²ç›¸
                const hue = (index * 0.12 + 0.08) % 1; // å½©è™¹è‰²ç›¸åˆ†å¸ƒ
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(hue, 0.8, 0.45),
                    shininess: 30,
                    flatShading: false
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = layer.y;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                treeGroup.add(mesh);
            });
            
            // æ ‘å¹²
            const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 2, 16);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x4a2f0f });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = -1;
            trunk.castShadow = true;
            treeGroup.add(trunk);
            
            // æ ‘åº•åº§
            const baseGeometry = new THREE.CylinderGeometry(1.5, 2, 0.5, 32);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x2a1f0f });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = -2;
            base.receiveShadow = true;
            treeGroup.add(base);
            
            christmasTree = treeGroup;
            scene.add(christmasTree);
        }
        
        // ========== åˆ›å»ºæ˜Ÿæ˜Ÿ ==========
        function createStar() {
            const starGroup = new THREE.Group();
            
            // äº”è§’æ˜Ÿ
            const starShape = new THREE.Shape();
            const outerRadius = 0.6;
            const innerRadius = 0.25;
            
            for (let i = 0; i < 10; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const angle = (i * Math.PI / 5) - Math.PI / 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) {
                    starShape.moveTo(x, y);
                } else {
                    starShape.lineTo(x, y);
                }
            }
            starShape.closePath();
            
            const extrudeSettings = { depth: 0.15, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05 };
            const starGeometry = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
            const starMaterial = new THREE.MeshPhongMaterial({
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.5,
                shininess: 100
            });
            
            const starMesh = new THREE.Mesh(starGeometry, starMaterial);
            starMesh.rotation.x = Math.PI;
            starGroup.add(starMesh);
            
            // æ˜Ÿæ˜Ÿå‘å…‰æ•ˆæœ
            const glowGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 0.15
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            starGroup.add(glow);
            
            starGroup.position.y = 8.8;
            star = starGroup;
            scene.add(starGroup);
        }
        
        // ========== åˆ›å»ºè£…é¥°å“ ==========
        function createOrnaments() {
            const ornamentPositions = [];
            
            // ä¸ºæ¯å±‚ç”Ÿæˆè£…é¥°ä½ç½®
            const layers = [
                { y: 1.5, radiusRange: [[0.5, 2.5]], count: 8 },
                { y: 3.5, radiusRange: [[0.3, 2.0]], count: 10 },
                { y: 5.5, radiusRange: [[0.2, 1.4]], count: 12 },
                { y: 7.0, radiusRange: [[0.1, 0.8]], count: 8 }
            ];
            
            layers.forEach(layer => {
                for (let i = 0; i < layer.count; i++) {
                    const angle = (i / layer.count) * Math.PI * 2 + Math.random() * 0.3;
                    const radius = layer.radiusRange[0][0] + Math.random() * (layer.radiusRange[0][1] - layer.radiusRange[0][0]);
                    
                    ornamentPositions.push({
                        x: Math.cos(angle) * radius,
                        y: layer.y + (Math.random() - 0.5) * 0.8,
                        z: Math.sin(angle) * radius,
                        color: CONFIG.ornamentColors[Math.floor(Math.random() * CONFIG.ornamentColors.length)],
                        size: 0.15 + Math.random() * 0.1
                    });
                }
            });
            
            ornamentPositions.forEach((pos, index) => {
                // è£…é¥°çƒ - äº”å½©é¢œè‰²
                const geometry = new THREE.SphereGeometry(pos.size, 16, 16);
                const hue = (index * 0.05) % 1;
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(hue, 0.9, 0.5),
                    shininess: 80,
                    specular: 0xffffff
                });
                const ornament = new THREE.Mesh(geometry, material);
                ornament.position.set(pos.x, pos.y, pos.z);
                ornament.castShadow = true;
                
                // æ·»åŠ é‡‘å±ç¯
                const ringGeometry = new THREE.TorusGeometry(pos.size * 0.3, 0.02, 8, 16);
                const ringMaterial = new THREE.MeshPhongMaterial({ color: 0xc0c0c0, shininess: 100 });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.y = pos.size * 0.8;
                ornament.add(ring);
                
                scene.add(ornament);
                ornaments.push({
                    mesh: ornament,
                    originalY: pos.y,
                    phase: Math.random() * Math.PI * 2
                });
            });
        }
        
        // ========== åˆ›å»ºé“ƒé“› ==========
        function createBells() {
            const bellGroup = new THREE.Group();
            const bellCount = 12;
            const bellOrbitHeights = [0.5, 2, 3.5, 5, 6.5];
            
            bellOrbitHeights.forEach((orbitY, orbitIndex) => {
                for (let i = 0; i < bellCount; i++) {
                    const bellGeometry = new THREE.SphereGeometry(0.12, 16, 16);
                    const bellMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffd700,
                        shininess: 100,
                        specular: 0xffffff
                    });
                    const bell = new THREE.Mesh(bellGeometry, bellMaterial);
                    
                    bell.userData = {
                        orbitRadius: 5.5 - orbitIndex * 0.8,
                        orbitSpeed: 0.3 + orbitIndex * 0.08,
                        orbitY: orbitY,
                        orbitIndex: orbitIndex,
                        angle: (i / bellCount) * Math.PI * 2 + orbitIndex * 0.3
                    };
                    
                    bellGroup.add(bell);
                    bells.push(bell);
                }
            });
            
            scene.add(bellGroup);
            return bellGroup;
        }
        
        // ========== åˆ›å»ºç¯å…‰ ==========
        function createLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
            scene.add(ambientLight);
            
            // ä¸»å…‰æº
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024;
            mainLight.shadow.mapSize.height = 1024;
            scene.add(mainLight);
            
            // é¡¶éƒ¨ç‚¹å…‰æºï¼ˆæ¨¡æ‹Ÿæ˜Ÿæ˜Ÿå‘å…‰ï¼‰
            const starLight = new THREE.PointLight(0xffd700, 2, 10);
            starLight.position.set(0, 9, 0);
            scene.add(starLight);
            
            // å½©è‰²æ°›å›´ç¯
            const colors = [0xff0000, 0x00ff00, 0x0066ff];
            colors.forEach((color, i) => {
                const light = new THREE.PointLight(color, 0.5, 15);
                const angle = (i / colors.length) * Math.PI * 2;
                light.position.set(Math.cos(angle) * 5, 5, Math.sin(angle) * 5);
                scene.add(light);
            });

            // ========== æ˜Ÿç³»æ•ˆæœ ==========
            const galaxyGroup = new THREE.Group();
            
            // æ˜Ÿç³»ä¸­å¿ƒå‘å…‰æ ¸å¿ƒ
            const coreGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 0.9
            });
            galaxyCore = new THREE.Mesh(coreGeometry, coreMaterial);
            galaxyGroup.add(galaxyCore);
            
            // ä¸­å¿ƒå…‰æ™•
            for (let i = 0; i < 3; i++) {
                const glowGeometry = new THREE.SphereGeometry(1 + i * 0.4, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(0.12, 1, 0.5 + i * 0.1),
                    transparent: true,
                    opacity: 0.3 - i * 0.08,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                galaxyGroup.add(glow);
            }
            
            // èºæ—‹è‡‚ç²’å­
            const armCount = 5;
            const particlesPerArm = 60;
            const maxRadius = 6;
            
            for (let arm = 0; arm < armCount; arm++) {
                for (let i = 0; i < particlesPerArm; i++) {
                    const progress = i / particlesPerArm;
                    const radius = progress * maxRadius;
                    const angleOffset = (arm / armCount) * Math.PI * 2;
                    const spiralAngle = angleOffset + progress * Math.PI * 3;
                    
                    // ç²’å­å¤§å°éšè·ç¦»å˜åŒ–
                    const particleSize = (1 - progress) * 0.08 + 0.02;
                    const particleGeometry = new THREE.SphereGeometry(particleSize, 8, 8);
                    
                    // é¢œè‰²æ¸å˜ï¼šä¸­å¿ƒé‡‘è‰² -> å¤–å›´è“è‰²/ç´«è‰²
                    const hue = 0.12 - progress * 0.1;
                    const lightness = 0.5 + progress * 0.3;
                    const particleMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color().setHSL(hue, 0.8, lightness),
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    
                    // éšæœºåç§»
                    const randomOffset = (Math.random() - 0.5) * 0.5 * (1 - progress);
                    
                    particle.position.x = Math.cos(spiralAngle) * (radius + randomOffset);
                    particle.position.z = Math.sin(spiralAngle) * (radius + randomOffset);
                    particle.position.y = (Math.random() - 0.5) * 0.5 * (1 - progress);
                    
                    particle.userData = {
                        baseAngle: spiralAngle,
                        baseRadius: radius + randomOffset,
                        height: particle.position.y,
                        speed: 0.02 + (1 - progress) * 0.03,
                        arm: arm
                    };
                    
                    galaxyGroup.add(particle);
                    galaxyParticles.push(particle);
                }
            }
            
            // æ•£å°„æ˜Ÿæ˜Ÿï¼ˆèƒŒæ™¯ï¼‰
            const starCount = 100;
            for (let i = 0; i < starCount; i++) {
                const starGeometry = new THREE.SphereGeometry(0.03, 4, 4);
                const starMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.2 + 0.5, 0.5, 0.8),
                    transparent: true,
                    opacity: 0.6
                });
                const star = new THREE.Mesh(starGeometry, starMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const radius = 4 + Math.random() * 8;
                
                star.position.x = Math.cos(angle) * radius;
                star.position.z = Math.sin(angle) * radius;
                star.position.y = (Math.random() - 0.5) * 8;
                
                star.userData = {
                    baseAngle: angle,
                    baseRadius: radius,
                    baseY: star.position.y,
                    speed: 0.01 + Math.random() * 0.02,
                    twinkleSpeed: 2 + Math.random() * 3
                };
                
                galaxyGroup.add(star);
                galaxyStars.push(star);
            }
            
            galaxyGroup.position.y = 3;
            scene.add(galaxyGroup);
        }
        
        // ========== åˆ›å»ºå›¾ç‰‡æ ‡ç­¾ ==========
        let photoDisplays = [];
        let photoShowTimer = null;
        let currentPhotoIndex_3d = 0;
        
        function createPhotoDisplay() {
            const photoCount = 3;
            
            for (let i = 0; i < photoCount; i++) {
                const photoGroup = new THREE.Group();
                
                // å›¾ç‰‡æ ‡ç­¾å¹³é¢
                const planeGeometry = new THREE.PlaneGeometry(0.5, 0.5);
                const planeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                const photoMesh = new THREE.Mesh(planeGeometry, planeMaterial);
                
                // è£…é¥°è¾¹æ¡†
                const borderGeometry = new THREE.RingGeometry(0.28, 0.3, 32);
                const borderMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.position.z = 0.01;
                
                photoGroup.add(photoMesh);
                photoGroup.add(border);
                
                // åˆå§‹ä½ç½®ï¼ˆåœ¨æ ‘å‘¨å›´ï¼‰
                const angle = (i / photoCount) * Math.PI * 2;
                photoGroup.position.set(
                    Math.cos(angle) * 1.2,  // x
                    4,                      // y
                    Math.sin(angle) * 1.2 + 0.8  // z
                );
                photoGroup.rotation.x = 0.3;
                
                // å­˜å‚¨å¼•ç”¨
                photoGroup.userData = {
                    mesh: photoMesh,
                    border: border,
                    angle: angle,
                    baseAngle: angle
                };
                
                christmasTree.add(photoGroup);
                photoDisplays.push(photoGroup);
            }
        }
        
        // ========== å•å¼ å›¾ç‰‡åœ¨æ ‘ä¸Šæ”¾å¤§æ˜¾ç¤º ==========
        let singlePhotoMesh = null;
        
        function showSinglePhotoOnTree(imagePath) {
            if (photoShowTimer) {
                clearTimeout(photoShowTimer);
                photoShowTimer = null;
            }
            
            // ç§»é™¤å·²å­˜åœ¨çš„å•å¼ å›¾ç‰‡
            if (singlePhotoMesh) {
                scene.remove(singlePhotoMesh);
                singlePhotoMesh.geometry.dispose();
                singlePhotoMesh.material.dispose();
                singlePhotoMesh = null;
            }
            
            const textureLoader = new THREE.TextureLoader();
            
            textureLoader.load(
                imagePath,
                function(texture) {
                    // åˆ›å»ºå›¾ç‰‡å¹³é¢ - å°ºå¯¸å¤§åˆ°èƒ½é®ä½æ ‘
                    const photoGeometry = new THREE.PlaneGeometry(4, 4);
                    const photoMaterial = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 1,
                        side: THREE.DoubleSide
                    });
                    
                    singlePhotoMesh = new THREE.Mesh(photoGeometry, photoMaterial);
                    
                    // æ”¾ç½®åœ¨ç›¸æœºæ­£å‰æ–¹ï¼Œé®ä½æ ‘
                    singlePhotoMesh.position.set(0, 2, 5);
                    singlePhotoMesh.scale.set(0.01, 0.01, 0.01);
                    singlePhotoMesh.renderOrder = 9999;
                    singlePhotoMesh.material.depthTest = false;
                    
                    // æ·»åŠ å‘å…‰è¾¹æ¡†
                    const borderGeometry = new THREE.PlaneGeometry(4.3, 4.3);
                    const borderMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffd700,
                        transparent: true,
                        opacity: 0.8,
                        side: THREE.DoubleSide
                    });
                    const borderMesh = new THREE.Mesh(borderGeometry, borderMaterial);
                    borderMesh.position.z = -0.01;
                    borderMesh.renderOrder = 9999;
                    borderMesh.material.depthTest = false;
                    singlePhotoMesh.add(borderMesh);
                    
                    scene.add(singlePhotoMesh);
                    
                    // æ”¾å¤§åŠ¨ç”» - ä»å¾ˆå°æ”¾å¤§åˆ°èƒ½é®ä½æ ‘
                    const startTime = Date.now();
                    const duration = 800;
                    const targetScale = 1;
                    
                    function animateScale() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easeProgress = 1 - Math.pow(1 - progress, 3);
                        
                        if (singlePhotoMesh) {
                            singlePhotoMesh.scale.set(
                                0.01 + (targetScale - 0.01) * easeProgress,
                                0.01 + (targetScale - 0.01) * easeProgress,
                                0.01 + (targetScale - 0.01) * easeProgress
                            );
                        }
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateScale);
                        }
                    }
                    
                    animateScale();
                    
                    // 3ç§’åéšè—
                    photoShowTimer = setTimeout(function() {
                        if (singlePhotoMesh) {
                            scene.remove(singlePhotoMesh);
                            singlePhotoMesh.geometry.dispose();
                            singlePhotoMesh.material.dispose();
                            singlePhotoMesh = null;
                        }
                        photoShowTimer = null;
                    }, 3000);
                },
                undefined,
                function(err) {
                    console.error('åŠ è½½å›¾ç‰‡å¤±è´¥:', err);
                }
            );
        }
        
        // ========== æ˜¾ç¤ºå›¾ç‰‡æ ‡ç­¾ ==========
        function showPhotoOnTree(imagePaths) {
            if (photoShowTimer) {
                clearTimeout(photoShowTimer);
                photoShowTimer = null;
            }
            
            const textureLoader = new THREE.TextureLoader();
            
            // åŠ è½½æ‰€æœ‰å›¾ç‰‡
            let loadedCount = 0;
            const totalPhotos = imagePaths.length;
            
            imagePaths.forEach((imagePath, index) => {
                textureLoader.load(
                    imagePath,
                    function(texture) {
                        if (photoDisplays[index]) {
                            const photoGroup = photoDisplays[index];
                            photoGroup.userData.mesh.material.map = texture;
                            photoGroup.userData.mesh.material.opacity = 1;
                            photoGroup.userData.mesh.material.needsUpdate = true;
                            
                            photoGroup.userData.border.material.opacity = 1;
                        }
                        
                        loadedCount++;
                        
                        // æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæˆåå¼€å§‹åŠ¨ç”»
                        if (loadedCount === totalPhotos) {
                            startPhotoRotationAnimation();
                        }
                    },
                    undefined,
                    function(err) {
                        console.error('åŠ è½½å›¾ç‰‡å¤±è´¥:', err);
                        loadedCount++;
                        if (loadedCount === totalPhotos) {
                            startPhotoRotationAnimation();
                        }
                    }
                );
            });
        }
        
        // ========== å›¾ç‰‡æ—‹è½¬åŠ¨ç”» ==========
        function startPhotoRotationAnimation() {
            const startTime = Date.now();
            const duration = 2000;
            const rotationRadius = 1.5;
            
            function animatePhotoRotation() {
                const elapsed = Date.now() - startTime;
                
                if (elapsed < duration) {
                    // å›´ç»•æ ‘ä¸­å¿ƒæ—‹è½¬
                    photoDisplays.forEach((photoGroup, index) => {
                        const userData = photoGroup.userData;
                        const newAngle = userData.baseAngle + elapsed * 0.003;
                        
                        photoGroup.position.x = Math.cos(newAngle) * rotationRadius;
                        photoGroup.position.z = Math.sin(newAngle) * rotationRadius + 0.8;
                    });
                    
                    requestAnimationFrame(animatePhotoRotation);
                } else {
                    // åŠ¨ç”»ç»“æŸï¼Œè¿”å›é»˜è®¤ä½ç½®
                    photoDisplays.forEach((photoGroup, index) => {
                        const userData = photoGroup.userData;
                        photoGroup.position.x = Math.cos(userData.baseAngle) * 1.2;
                        photoGroup.position.z = Math.sin(userData.baseAngle) * 1.2 + 0.8;
                        
                        // éšè—æ‰€æœ‰å›¾ç‰‡
                        photoGroup.userData.mesh.material.opacity = 0;
                        photoGroup.userData.mesh.material.map = null;
                        photoGroup.userData.border.material.opacity = 0;
                    });
                    
                    photoShowTimer = null;
                }
            }
            
            animatePhotoRotation();
        }
        
        // ========== æ›´æ–°å±•ç¤ºçš„å›¾ç‰‡ ==========
        function updatePhotoDisplay(imagePath) {
            const textureLoader = new THREE.TextureLoader();
            
            textureLoader.load(
                imagePath,
                function(texture) {
                    photoDisplayTexture = texture;
                    if (photoDisplayMesh) {
                        photoDisplayMesh.material.map = texture;
                        photoDisplayMesh.material.needsUpdate = true;
                    }
                    showPhotoDisplay();
                },
                undefined,
                function(err) {
                    console.error('åŠ è½½å›¾ç‰‡å¤±è´¥:', err);
                }
            );
        }
        
        // ========== æ˜¾ç¤ºå›¾ç‰‡å±•ç¤º ==========
        function showPhotoDisplay() {
            if (photoDisplay) {
                photoDisplay.visible = true;
                isPhotoDisplayVisible = true;
                isPhotoZoomed = false;
                photoDisplay.scale.set(1, 1, 1);
            }
        }
        
        // ========== éšè—å›¾ç‰‡å±•ç¤º ==========
        function hidePhotoDisplay() {
            if (photoDisplay) {
                photoDisplay.visible = false;
                isPhotoDisplayVisible = false;
                isPhotoZoomed = false;
            }
        }
        
        // ========== å›¾ç‰‡å±•ç¤ºç‚¹å‡»å¤„ç† ==========
        function onPhotoDisplayClick(event) {
            event.stopPropagation();
            
            photoDisplayClickCount++;
            
            if (photoDisplayClickCount === 1) {
                photoDisplayClickTimer = setTimeout(function() {
                    photoDisplayClickCount = 0;
                    
                    if (isPhotoDisplayVisible) {
                        if (isPhotoZoomed) {
                            photoDisplay.scale.set(1, 1, 1);
                            isPhotoZoomed = false;
                        } else {
                            photoDisplay.scale.set(2, 2, 2);
                            isPhotoZoomed = true;
                        }
                    }
                }, 300);
            } else if (photoDisplayClickCount === 2) {
                clearTimeout(photoDisplayClickTimer);
                photoDisplayClickCount = 0;
                
                hidePhotoDisplay();
            }
        }
        
        // ========== åˆ›å»ºç²’å­ ==========
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                
                // éšæœºåˆ†å¸ƒåœ¨æ ‘å‘¨å›´
                const radius = 4 + Math.random() * 8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = (Math.random() - 0.5) * 15;
                positions[i3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
                
                // ç™½è‰²åˆ°é‡‘è‰²
                const color = new THREE.Color();
                color.setHSL(0.1 + Math.random() * 0.1, 0.8, 0.7 + Math.random() * 0.3);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                sizes[i] = 0.02 + Math.random() * 0.05;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // å­˜å‚¨å¼•ç”¨ç”¨äºåŠ¨ç”»
            scene.userData.particles = particles;
            scene.userData.particlePositions = positions;
            scene.userData.particleGeometry = geometry;
            
            // ä¿å­˜åŸå§‹ä½ç½®
            originalParticlePositions = new Float32Array(positions);
        }
        
        // ========== åˆ›å»ºé›ªèŠ± ==========
        function createSnow() {
            const snowContainer = document.getElementById('snow-container');
            
            for (let i = 0; i < 80; i++) {
                createSnowflake(snowContainer, i);
            }
        }
        
        function createSnowflake(container, index) {
            const snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.innerHTML = 'â„';
            snowflake.style.left = Math.random() * 100 + '%';
            snowflake.style.animationDuration = (6 + Math.random() * 8) + 's';
            snowflake.style.animationDelay = Math.random() * 5 + 's';
            snowflake.style.fontSize = (8 + Math.random() * 10) + 'px';
            snowflake.dataset.index = index;
            snowflake.dataset.originalLeft = snowflake.style.left;
            snowflake.dataset.speed = parseFloat(snowflake.style.animationDuration);
            snowflake.dataset.delay = parseFloat(snowflake.style.animationDelay);
            snowflake.dataset.exploded = 'false';
            
            // é›ªèŠ±ç‚¹å‡»çˆ†ç‚¸
            snowflake.addEventListener('click', (e) => {
                e.stopPropagation();
                explodeSnowflake(snowflake);
            });
            
            // ç›‘å¬åŠ¨ç”»ç»“æŸï¼ˆé›ªèŠ±è½åœ°ï¼‰
            snowflake.addEventListener('animationiteration', (e) => {
                // é›ªèŠ±é‡æ–°å¼€å§‹ä¸‹è½æ—¶ï¼Œä¸åšå¤„ç†
            });
            
            // ç›‘å¬åŠ¨ç”»ç»“æŸï¼ˆä¸€æ¬¡æ€§åŠ¨ç”»ï¼‰
            snowflake.addEventListener('animationend', (e) => {
                if (snowflake.dataset.exploded === 'false' && snowflake.parentElement) {
                    // é›ªèŠ±è½åˆ°æœ€åº•ä¸‹ï¼Œçˆ†ç‚¸æˆå¤šä¸ªå°é›ªèŠ±
                    explodeOnGround(snowflake, container);
                }
            });
            
            container.appendChild(snowflake);
            snowflakes.push(snowflake);
        }
        
        // é›ªèŠ±è½åœ°çˆ†ç‚¸
        function explodeOnGround(snowflake, container) {
            if (!snowflake.parentElement) return;
            
            const rect = snowflake.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = window.innerHeight - 50;
            
            // åˆ›å»ºå¤šä¸ªå°é›ªèŠ±
            const miniCount = 5 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < miniCount; i++) {
                const miniFlake = document.createElement('div');
                miniFlake.className = 'snowflake';
                miniFlake.innerHTML = 'â„';
                miniFlake.style.left = (centerX / window.innerWidth * 100) + '%';
                miniFlake.style.top = (window.innerHeight - 80) + 'px';
                miniFlake.style.fontSize = (4 + Math.random() * 4) + 'px';
                miniFlake.style.animation = 'none';
                miniFlake.style.opacity = '1';
                miniFlake.style.transition = 'all 0.5s ease-out';
                miniFlake.dataset.exploded = 'true';
                
                container.appendChild(miniFlake);
                
                // å°é›ªèŠ±é£æ•£æ•ˆæœ
                setTimeout(() => {
                    const angle = (Math.random() * Math.PI) + Math.PI; // å‘å››å‘¨æ•£å¼€
                    const distance = 50 + Math.random() * 100;
                    const endX = Math.cos(angle) * distance;
                    const endY = -Math.random() * 150 - 50;
                    
                    miniFlake.style.left = ((centerX + endX) / window.innerWidth * 100) + '%';
                    miniFlake.style.top = (window.innerHeight + endY) + 'px';
                    miniFlake.style.opacity = '0';
                    miniFlake.style.transform = 'scale(0) rotate(180deg)';
                }, 10);
                
                // ç§»é™¤å°é›ªèŠ±
                setTimeout(() => {
                    if (miniFlake.parentElement) {
                        miniFlake.remove();
                    }
                }, 600);
            }
            
            // ç§»é™¤åŸé›ªèŠ±
            const originalLeft = snowflake.dataset.originalLeft;
            snowflake.remove();
            
            // åˆ›å»ºæ–°é›ªèŠ±è¡¥å……
            setTimeout(() => {
                if (container) {
                    createSnowflake(container, Date.now());
                }
            }, 500);
        }
        
        // é›ªèŠ±çˆ†ç‚¸æ•ˆæœï¼ˆç‚¹å‡»ï¼‰
        function explodeSnowflake(snowflake) {
            if (snowflakesExploded) {
                resetSnowflakes();
                return;
            }
            
            snowflakesExploded = true;
            const container = document.getElementById('snow-container');
            const rect = snowflake.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // åˆ›å»ºçˆ†ç‚¸ç²’å­æ•ˆæœ
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const particle = document.createElement('div');
                particle.innerHTML = 'â„';
                particle.style.position = 'fixed';
                particle.style.left = centerX + 'px';
                particle.style.top = centerY + 'px';
                particle.style.fontSize = (6 + Math.random() * 12) + 'px';
                particle.style.color = 'rgba(255, 255, 255, ' + (0.6 + Math.random() * 0.4) + ')';
                particle.style.pointerEvents = 'none';
                particle.style.zIndex = '999';
                particle.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                
                container.appendChild(particle);
                
                // å‘å››å‘¨é£æ•£
                setTimeout(() => {
                    const angle = (Math.random() * Math.PI * 2);
                    const distance = 100 + Math.random() * 200;
                    const spreadX = Math.cos(angle) * distance;
                    const spreadY = Math.sin(angle) * distance - 50;
                    
                    particle.style.left = (centerX + spreadX) + 'px';
                    particle.style.top = (centerY + spreadY) + 'px';
                    particle.style.opacity = '0';
                    particle.style.transform = 'scale(0) rotate(' + (Math.random() * 360) + 'deg)';
                }, 10);
                
                // ç§»é™¤ç²’å­
                setTimeout(() => {
                    if (particle.parentElement) {
                        particle.remove();
                    }
                }, 700);
            }
            
            // é—ªå…‰æ•ˆæœ
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.left = centerX + 'px';
            flash.style.top = centerY + 'px';
            flash.style.width = '10px';
            flash.style.height = '10px';
            flash.style.background = 'radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,255,255,0) 70%)';
            flash.style.borderRadius = '50%';
            flash.style.transform = 'translate(-50%, -50%)';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '998';
            flash.style.transition = 'all 0.3s ease-out';
            container.appendChild(flash);
            
            setTimeout(() => {
                flash.style.width = '300px';
                flash.style.height = '300px';
                flash.style.opacity = '0';
            }, 10);
            
            setTimeout(() => {
                if (flash.parentElement) {
                    flash.remove();
                }
            }, 400);
            
            // æ‰€æœ‰é›ªèŠ±å‘å¤–æ‰©æ•£
            snowflakes.forEach((flake, index) => {
                setTimeout(() => {
                    if (!flake.parentElement) return;
                    
                    const flakeRect = flake.getBoundingClientRect();
                    const flakeX = flakeRect.left + flakeRect.width / 2;
                    const flakeY = flakeRect.top + flakeRect.height / 2;
                    
                    const angle = Math.atan2(flakeY - centerY, flakeX - centerX);
                    const distance = 150 + Math.random() * 200;
                    const endX = Math.cos(angle) * distance;
                    const endY = Math.sin(angle) * distance;
                    
                    flake.style.animation = 'none';
                    flake.style.transition = 'all 0.5s ease-out';
                    
                    const currentX = parseFloat(flake.style.left);
                    flake.style.left = (currentX + endX / window.innerWidth * 100) + '%';
                    flake.style.top = (flakeY + endY) + 'px';
                    flake.style.opacity = '0';
                    flake.style.transform = 'scale(0) rotate(180deg)';
                }, index * 15);
            });
        }
        
        // é‡ç½®é›ªèŠ±
        function resetSnowflakes() {
            snowflakesExploded = false;
            
            // æ¸…é™¤æ‰€æœ‰é›ªèŠ±
            snowflakes.forEach(flake => {
                if (flake.parentElement) {
                    flake.remove();
                }
            });
            snowflakes = [];
            
            // é‡æ–°åˆ›å»ºé›ªèŠ±
            const snowContainer = document.getElementById('snow-container');
            if (snowContainer) {
                for (let i = 0; i < 80; i++) {
                    createSnowflake(snowContainer, Date.now() + i);
                }
            }
        }
        
        // ========== äº‹ä»¶ç›‘å¬ ==========
        function setupEventListeners() {
            // é¼ æ ‡/è§¦æ‘¸å¼€å§‹
            const onStart = (x, y) => {
                isDragging = true;
                previousMousePosition = { x, y };
            };
            
            // é¼ æ ‡/è§¦æ‘¸ç§»åŠ¨
            const onMove = (x, y) => {
                if (!isDragging) return;
                
                const deltaX = x - previousMousePosition.x;
                const deltaY = y - previousMousePosition.y;
                
                targetRotation.y += deltaX * 0.005;
                targetRotation.x += deltaY * 0.005;
                targetRotation.x = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotation.x));
                
                previousMousePosition = { x, y };
            };
            
            // é¼ æ ‡/è§¦æ‘¸ç»“æŸ
            const onEnd = () => {
                isDragging = false;
            };
            
            // é¼ æ ‡äº‹ä»¶
            renderer.domElement.addEventListener('mousedown', (e) => onStart(e.clientX, e.clientY));
            renderer.domElement.addEventListener('mousemove', (e) => onMove(e.clientX, e.clientY));
            renderer.domElement.addEventListener('mouseup', onEnd);
            renderer.domElement.addEventListener('mouseleave', onEnd);
            
            // æ»šè½®ç¼©æ”¾
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                targetCameraDistance += e.deltaY * 0.01;
                targetCameraDistance = Math.max(5, Math.min(25, targetCameraDistance));
            }, { passive: false });
            
            // ç‚¹å‡»ç²’å­çˆ†ç‚¸
            renderer.domElement.addEventListener('click', onParticleClick);
            renderer.domElement.addEventListener('touchend', (e) => {
                if (e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    onParticleClick({
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                }
                onEnd();
            });
            
            // è§¦æ‘¸äº‹ä»¶
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    onStart(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    photoPinchStartDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    photoInitialScale = photoScale;
                }
            });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    onMove(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const scale = (currentDistance / photoPinchStartDistance) * photoInitialScale;
                    photoScale = Math.max(0.5, Math.min(3, scale));
                    updatePhotoScale();
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchend', onEnd);
            
            // ç…§ç‰‡ç‚¹å‡»äº‹ä»¶ - åŒå‡»åœ¨æ ‘ä¸Šæ”¾å¤§æ˜¾ç¤ºå•å¼ å›¾ç‰‡
            let photoClickCount = 0;
            let photoClickTimer = null;
            
            document.querySelectorAll('.gallery-photo').forEach((photo, index) => {
                photo.addEventListener('click', (e) => {
                    e.stopPropagation();
                    photoClickCount++;
                    
                    if (photoClickCount === 1) {
                        photoClickTimer = setTimeout(function() {
                            photoClickCount = 0;
                        }, 350);
                    } else if (photoClickCount === 2) {
                        clearTimeout(photoClickTimer);
                        photoClickCount = 0;
                        
                        // æ˜¾ç¤ºå•å¼ å›¾ç‰‡åœ¨æ ‘ä¸Šæ”¾å¤§
                        showSinglePhotoOnTree(CONFIG.photos[index]);
                    }
                });
            });
            
            // ç…§ç‰‡åŒå‡»æ”¾å¤§åŠŸèƒ½
            setupPhotoZoom();
            
            // é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closePhotoModal();
                }
                if (e.key === 'ArrowLeft') {
                    navigatePhoto(-1);
                }
                if (e.key === 'ArrowRight') {
                    navigatePhoto(1);
                }
                if (e.key === '+' || e.key === '=') {
                    photoScale = Math.min(3, photoScale + 0.2);
                    updatePhotoScale();
                }
                if (e.key === '-') {
                    photoScale = Math.max(0.5, photoScale - 0.2);
                    updatePhotoScale();
                }
            });
            
            // é¼ æ ‡æ»šè½®ç¼©æ”¾
            document.addEventListener('wheel', (e) => {
                if (document.getElementById('photo-modal').classList.contains('active')) {
                    e.preventDefault();
                    photoScale += e.deltaY * -0.001;
                    photoScale = Math.max(0.5, Math.min(3, photoScale));
                    updatePhotoScale();
                }
            }, { passive: false });
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
            
            // å…³é—­æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            document.getElementById('close-btn').addEventListener('click', function(e) {
                e.stopPropagation();
                closePhotoModal();
            });
            
            // éŸ³ä¹æ§åˆ¶
            setupMusicControl();
        }
        
        // å›¾ç‰‡åŒå‡»æ”¾å¤§åŠŸèƒ½
        function setupPhotoZoom() {
            const modalPhotoEl = document.getElementById('modal-photo');
            const photoContainer = document.getElementById('photo-container');
            const photoModal = document.getElementById('photo-modal');
            const zoomHint = document.getElementById('zoom-hint');
            
            let isZoomed = false;
            let clickCount = 0;
            let clickTimer = null;
            
            // è°ƒè¯•ï¼šæµ‹è¯•ç‚¹å‡»
            modalPhotoEl.addEventListener('click', function(e) {
                console.log('å›¾ç‰‡è¢«ç‚¹å‡»äº†');
            });
            
            // åŒå‡»å›¾ç‰‡æ”¾å¤§
            modalPhotoEl.addEventListener('dblclick', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('åŒå‡»å›¾ç‰‡ï¼Œåˆ‡æ¢æ”¾å¤§çŠ¶æ€');
                
                isZoomed = !isZoomed;
                
                if (isZoomed) {
                    photoContainer.style.position = 'fixed';
                    photoContainer.style.top = '0';
                    photoContainer.style.left = '0';
                    photoContainer.style.width = '100vw';
                    photoContainer.style.height = '100vh';
                    photoContainer.style.backgroundColor = '#000';
                    photoContainer.style.zIndex = '2147483647';
                    photoContainer.style.overflow = 'hidden';
                    
                    modalPhotoEl.style.width = '100vw';
                    modalPhotoEl.style.height = '100vh';
                    modalPhotoEl.style.objectFit = 'contain';
                    modalPhotoEl.style.transform = 'none';
                    modalPhotoEl.style.borderRadius = '0';
                    modalPhotoEl.style.boxShadow = 'none';
                    
                    const heartBorder = photoContainer.querySelector('.heart-border');
                    if (heartBorder) heartBorder.style.display = 'none';
                    
                    zoomHint.style.display = 'block';
                } else {
                    photoContainer.style.position = '';
                    photoContainer.style.top = '';
                    photoContainer.style.left = '';
                    photoContainer.style.width = '';
                    photoContainer.style.height = '';
                    photoContainer.style.backgroundColor = '';
                    photoContainer.style.zIndex = '';
                    
                    modalPhotoEl.style.width = '';
                    modalPhotoEl.style.height = '';
                    modalPhotoEl.style.objectFit = '';
                    modalPhotoEl.style.transform = '';
                    modalPhotoEl.style.borderRadius = '';
                    modalPhotoEl.style.boxShadow = '';
                    
                    const heartBorder = photoContainer.querySelector('.heart-border');
                    if (heartBorder) heartBorder.style.display = '';
                    
                    zoomHint.style.display = 'none';
                }
            });
            
            // ç‚¹å‡»å®¹å™¨ä¹Ÿé˜»æ­¢å†’æ³¡
            photoContainer.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
            photoModal.addEventListener('click', function(e) {
                if (e.target === this) {
                    if (isZoomed) {
                        photoContainer.style.position = '';
                        photoContainer.style.top = '';
                        photoContainer.style.left = '';
                        photoContainer.style.width = '';
                        photoContainer.style.height = '';
                        photoContainer.style.backgroundColor = '';
                        photoContainer.style.zIndex = '';
                        
                        modalPhotoEl.style.width = '';
                        modalPhotoEl.style.height = '';
                        modalPhotoEl.style.objectFit = '';
                        modalPhotoEl.style.transform = '';
                        modalPhotoEl.style.borderRadius = '';
                        modalPhotoEl.style.boxShadow = '';
                        
                        const heartBorder = photoContainer.querySelector('.heart-border');
                        if (heartBorder) heartBorder.style.display = '';
                        
                        zoomHint.style.display = 'none';
                        isZoomed = false;
                    } else {
                        closePhotoModal();
                    }
                }
            });
        }
        
        // éŸ³ä¹æ§åˆ¶åŠŸèƒ½
        function setupMusicControl() {
            const musicBtn = document.getElementById('music-btn');
            const bgm = document.getElementById('bgm');
            let isMusicPlaying = false;
            
            bgm.volume = 0.5;
            
            musicBtn.onclick = function() {
                if (isMusicPlaying) {
                    bgm.pause();
                    this.textContent = 'ğŸ”‡';
                    this.classList.remove('music-playing');
                    this.classList.add('music-paused');
                    isMusicPlaying = false;
                } else {
                    bgm.play().then(() => {
                        this.textContent = 'ğŸµ';
                        this.classList.remove('music-paused');
                        this.classList.add('music-playing');
                        isMusicPlaying = true;
                    }).catch(e => {
                        console.log('æ’­æ”¾å¤±è´¥:', e);
                    });
                }
            };
            
            // é¡µé¢ç‚¹å‡»ä»»æ„ä½ç½®æ’­æ”¾éŸ³ä¹
            document.addEventListener('click', function() {
                if (!isMusicPlaying && !bgm.paused === false) {
                    bgm.play().then(() => {
                        musicBtn.textContent = 'ğŸµ';
                        musicBtn.classList.remove('music-paused');
                        musicBtn.classList.add('music-playing');
                        isMusicPlaying = true;
                    }).catch(e => {});
                }
            }, { once: true });
            
            // é¡µé¢åŠ è½½åå°è¯•æ’­æ”¾
            setTimeout(() => {
                bgm.play().then(() => {
                    musicBtn.textContent = 'ğŸµ';
                    musicBtn.classList.remove('music-paused');
                    musicBtn.classList.add('music-playing');
                    isMusicPlaying = true;
                }).catch(e => {});
            }, 500);
        }
        
        // ç‚¹å‡»ç²’å­çˆ†ç‚¸æˆ–æ ‘åŠ é€Ÿ
        function onParticleClick(event) {
            // è®¡ç®—é¼ æ ‡ä½ç½®
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // æ£€æµ‹æ˜¯å¦ç‚¹å‡»åˆ°å›¾ç‰‡å±•ç¤º
            if (photoDisplay && photoDisplay.visible) {
                const photoIntersects = raycaster.intersectObject(photoDisplayMesh, true);
                if (photoIntersects.length > 0) {
                    onPhotoDisplayClick(event);
                    return;
                }
            }
            
            // æ£€æµ‹æ˜¯å¦ç‚¹å‡»åˆ°æ ‘
            const treeIntersects = raycaster.intersectObject(christmasTree, true);
            
            if (treeIntersects.length > 0) {
                // ç‚¹å‡»åˆ°æ ‘ï¼ŒåŠ é€Ÿæ—‹è½¬
                targetTreeRotationSpeed = 8;
                setTimeout(() => {
                    targetTreeRotationSpeed = 2.5;
                }, 2000);
            } else {
                // ç‚¹å‡»å…¶ä»–åŒºåŸŸï¼Œç²’å­çˆ†ç‚¸
                if (particlesExploded) {
                    resetParticles();
                } else {
                    explodeParticles();
                }
            }
        }
        
        function explodeParticles() {
            particlesExploded = true;
            explosionProgress = 0;
            explosionCenter.set(0, 4, 0);
        }
        
        function resetParticles() {
            particlesExploded = false;
            explosionProgress = 0;
        }
        
        function updateExplosion() {
            if (!particlesExploded && explosionProgress >= 1) return;
            
            const positions = scene.userData.particleGeometry.attributes.position.array;
            
            if (particlesExploded) {
                explosionProgress += 0.02;
                const easeProgress = Math.pow(explosionProgress, 0.5);
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    const originalX = originalParticlePositions[i3];
                    const originalY = originalParticlePositions[i3 + 1];
                    const originalZ = originalParticlePositions[i3 + 2];
                    
                    const dirX = originalX - explosionCenter.x;
                    const dirY = originalY - explosionCenter.y;
                    const dirZ = originalZ - explosionCenter.z;
                    const dist = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ) || 1;
                    
                    const explodeDistance = 8 + Math.random() * 4;
                    
                    positions[i3] = originalX + (dirX / dist) * explodeDistance * easeProgress;
                    positions[i3 + 1] = originalY + (dirY / dist) * explodeDistance * easeProgress + easeProgress * 2;
                    positions[i3 + 2] = originalZ + (dirZ / dist) * explodeDistance * easeProgress;
                }
            } else if (explosionProgress > 0 && explosionProgress < 1) {
                explosionProgress += 0.03;
                const easeProgress = 1 - Math.pow(1 - explosionProgress, 3);
                
                for (let i = 0; i < CONFIG.particleCount; i++) {
                    const i3 = i * 3;
                    const originalX = originalParticlePositions[i3];
                    const originalY = originalParticlePositions[i3 + 1];
                    const originalZ = originalParticlePositions[i3 + 2];
                    
                    positions[i3] = originalX * (1 - easeProgress);
                    positions[i3 + 1] = originalY * (1 - easeProgress);
                    positions[i3 + 2] = originalZ * (1 - easeProgress);
                }
            }
            
            scene.userData.particleGeometry.attributes.position.needsUpdate = true;
        }
        
        function openPhotoModal(index) {
            currentPhotoIndex = index;
            
            const modal = document.getElementById('photo-modal');
            const modalPhoto = document.getElementById('modal-photo');
            const photoContainer = document.getElementById('photo-container');
            
            console.log('openPhotoModal called, index:', index);
            console.log('modal element:', modal);
            console.log('modalPhoto element:', modalPhoto);
            
            photoScale = 1;
            modalPhoto.classList.remove('fullscreen');
            modalPhoto.style.transform = 'scale(1)';
            modalPhoto.src = CONFIG.photos[currentPhotoIndex];
            
            document.getElementById('photo-count').textContent = `${currentPhotoIndex + 1} / ${CONFIG.photos.length}`;
            
            document.querySelectorAll('.gallery-photo').forEach((photo, i) => {
                photo.classList.toggle('active', i === currentPhotoIndex);
            });
            
            modal.classList.add('active');
            modal.style.display = 'flex';
            modal.style.opacity = '1';
            
            window.currentModalPhoto = modalPhoto;
        }
        
        function closePhotoModal() {
            var modalPhoto = document.getElementById('modal-photo');
            modalPhoto.classList.remove('fullscreen');
            photoScale = 1;
            document.getElementById('photo-modal').classList.remove('active');
        }
        
        function updateModalPhoto() {
            const modalPhoto = document.getElementById('modal-photo');
            const count = document.getElementById('photo-count');
            
            modalPhoto.src = CONFIG.photos[currentPhotoIndex];
            modalPhoto.classList.remove('show');
            setTimeout(() => modalPhoto.classList.add('show'), 50);
            
            count.textContent = `${currentPhotoIndex + 1} / ${CONFIG.photos.length}`;
            
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.gallery-photo').forEach((photo, i) => {
                photo.classList.toggle('active', i === currentPhotoIndex);
            });
        }
        
        function navigatePhoto(direction) {
            currentPhotoIndex = (currentPhotoIndex + direction + CONFIG.photos.length) % CONFIG.photos.length;
            updateModalPhoto();
        }
        
        function updatePhotoScale() {
            const modalPhoto = document.getElementById('modal-photo');
            modalPhoto.style.transform = `scale(${photoScale})`;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function hideLoading() {
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                startBgSlideshow();
            }, 1000);
        }

        function startBgSlideshow() {
            let currentBgIndex = 0;
            const bgImages = document.querySelectorAll('.bg-image');
            
            setInterval(() => {
                bgImages[currentBgIndex].classList.remove('active');
                currentBgIndex = (currentBgIndex + 1) % bgImages.length;
                bgImages[currentBgIndex].classList.add('active');
            }, 3000);
        }
        
        // ========== åŠ¨ç”»å¾ªç¯ ==========
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // è‡ªåŠ¨æ—‹è½¬æ—¶é—´
            autoRotateTime += 0.01;
            
            // å¹³æ»‘ç›¸æœºç§»åŠ¨
            cameraDistance += (targetCameraDistance - cameraDistance) * 0.05;
            camera.position.z = cameraDistance;
            
            // å¹³æ»‘æ—‹è½¬
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;
            
            // å¹³æ»‘æ—‹è½¬é€Ÿåº¦
            treeRotationSpeed += (targetTreeRotationSpeed - treeRotationSpeed) * 0.02;
            
            // åœ£è¯æ ‘ä¸€ç›´ä¿æŒè‡ªåŠ¨æ—‹è½¬
            if (christmasTree) {
                christmasTree.rotation.y = autoRotateTime * treeRotationSpeed + currentRotation.y * 0.3;
                christmasTree.rotation.x = currentRotation.x * 0.3;
            }
            
            // æ˜Ÿæ˜Ÿæ—‹è½¬å’Œè„‰åŠ¨ - ç«‹èµ·æ¥å¹¶è‡ªè½¬
            if (star) {
                // é‡ç½®æ˜Ÿæ˜Ÿæ–¹å‘ä½¿å…¶ç«‹èµ·æ¥
                star.rotation.x = 0;
                star.rotation.z = 0;
                
                // è®©æ˜Ÿæ˜Ÿå›´ç»•è‡ªèº«å‚ç›´è½´æ—‹è½¬
                star.rotation.y += 0.02;
                
                // ä¿æŒè„‰åŠ¨æ•ˆæœ
                const scale = 1 + Math.sin(time * 3) * 0.1;
                star.scale.set(scale, scale, scale);
            }
            
            // è£…é¥°å“æ‘‡æ‘†
            ornaments.forEach(ornament => {
                ornament.mesh.rotation.y += 0.02;
                ornament.mesh.position.y = ornament.originalY + Math.sin(time * 2 + ornament.phase) * 0.05;
            });
            
            // é“ƒé“›ç¯ç»•æ—‹è½¬
            bells.forEach(bell => {
                bell.userData.angle += bell.userData.orbitSpeed * 0.02;
                bell.position.x = Math.cos(bell.userData.angle) * bell.userData.orbitRadius;
                bell.position.z = Math.sin(bell.userData.angle) * bell.userData.orbitRadius;
                bell.position.y = bell.userData.orbitY + Math.sin(time * 3 + bell.userData.angle) * 0.3;
            });
            
            // æ˜Ÿç³»èºæ—‹è‡‚æ—‹è½¬
            galaxyParticles.forEach(particle => {
                const data = particle.userData;
                const currentAngle = data.baseAngle + time * data.speed;
                
                particle.position.x = Math.cos(currentAngle) * data.baseRadius;
                particle.position.z = Math.sin(currentAngle) * data.baseRadius;
                particle.position.y = data.height + Math.sin(time * 2 + data.arm) * 0.2;
                
                // é—ªçƒæ•ˆæœ
                particle.material.opacity = 0.5 + Math.sin(time * 3 + data.baseRadius) * 0.3;
            });
            
            // èƒŒæ™¯æ˜Ÿæ˜Ÿé—ªçƒ
            galaxyStars.forEach(star => {
                const data = star.userData;
                data.baseAngle += data.speed * 0.01;
                
                star.position.x = Math.cos(data.baseAngle) * data.baseRadius;
                star.position.z = Math.sin(data.baseAngle) * data.baseRadius;
                star.position.y = data.baseY;
                
                // é—ªçƒæ•ˆæœ
                star.material.opacity = 0.3 + Math.sin(time * data.twinkleSpeed) * 0.3;
            });
            
            // æ˜Ÿç³»æ ¸å¿ƒè„‰åŠ¨
            if (galaxyCore) {
                const coreScale = 1 + Math.sin(time * 2) * 0.1;
                galaxyCore.scale.set(coreScale, coreScale, coreScale);
            }
            
            // ç²’å­æ—‹è½¬
            if (scene.userData.particles && !particlesExploded) {
                scene.userData.particles.rotation.y += 0.001;
            }
            
            // ç›¸æœºè½»å¾®ä¸Šä¸‹æµ®åŠ¨
            camera.position.y = 3 + Math.sin(time * 0.5) * 0.3;
            
            // æ›´æ–°çˆ†ç‚¸åŠ¨ç”»
            updateExplosion();
            
            renderer.render(scene, camera);
        }
        
        // å¯åŠ¨
        init();
    </script>
</body>
</html>
